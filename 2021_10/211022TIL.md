## 211021TIL

## 학습 내용

객체 지향에 대하여..
- 타입 내부에서 정의된 메서드가 내부 뿐만 아니라 외부에서도 사용되면 "변경에 취약한 구조"가 된다. 
- 역할 + 책임 + 협력
- 객체의 역할과 책임에 따라 타입을 구분해주는 것이 중요한 것 같다. 
- 은닉화는 접근 제어자만 붙인다고 되는 것이 아니다! 다른 목적으로는 변경의 영향을 최소화하는 것이다! 
	- 은닉화가 잘 되어있다면 해당 프로퍼티/메서드 변경 시 에러가 발생한다고 하더라도 내부에서만 발생하고, 외부에서는 발생하지 않을 것! ( = 덜 복잡해진다는 의미)



### Singleton

Singleton class는 어플리케이션이 몇 번이고 요청을 하더라고 동일한 인스턴스를 반환해준다. 일반적인 class는 원하는 만큼 부르면 인스턴스를 막 생성할 수 있지만, singleton은 딱 하나만 생성할 수 있다. 

즉, singleton은 클래스의 자원에 대한 전역 접근 지점을 제공한다. 그래서 singleton은 일반적인 서비스나 자원을 제공하는 클래스와 같이 단일 제어 지점이 요구되는 상황에서 사용된다. 

앞서 말한 것 처럼 동일한 인스턴스를 반환하는 것 뿐만 아니라, 인스턴스가 복제되거나, 메모리에 retaining, releasing 되는 것을 방지한다. 

이러한 singleton 클래스는 cocoa framework에서도 사용하고 있는데, `NSFileManager`, `NSWorkspace`, UIKit에서는 대표적으로 `UIApplication`이 포함된다. 

그렇다면 singleton은 어떻게 만들 수 있을까? 

```swift
class Score {
	static let shared = Score()
	private init() {}
}
```

공유되는 하나의 인스턴스를 사용하기 위해 클래스 내부에 타입 프로퍼티 형태로 인스턴스를 만들어준다. 

그리고 외부에서는 초기화되지 못하게 하기 위해 `init`에 `private`를 붙여 방지해준다. 

만약에 initialization 이후에 추가적인 세팅을 하고 싶다면 클로져 형태로 작성해주면 된다. 

```swift
class Score {
	static let shared: Score = {
		let instance = Score()
		// 추가 세팅
		return instance
    }()
	private init() {}
}
```

이제 `Score.shared`를 통해 접근하면 자원에 대해 어디서든 동일한 지점에 접근이 가능해진다!

### 실험실 (MVC-NotificationCenter)

코드는 올리면 안될 것 같으니... 

- KVO 방식 구현 
- Notification 방식 구현


## 고민한 점

주스 메이커 프로젝트 step 1에 대한 PR을 올린 이후 코멘트를 보고 많은 생각을 할 수 있었다. 

- 객체 지향 프로그래밍
	- 역할!!! 책임!! 협력!!
- 변경에 취약하지 않은 구조를 고민해보기
	- 은닉화
	- 적절한 기능의 분리
- 에러 핸들링
	- 에러 타입도 에러 케이스의 성격에 따라 분리하기
	- 폴더로 빼서 관리
	- throws는 해주되, 가장 끝 단에 사용하는 메서드에서 `do-catch로 에러 처리 해주기. 

리뷰어분께서 남겨주셨던 질문이 굉장히 밀도가 있는 질문이라고 생각되어, 숲재 토니와 많은 생각을 했던 것 같다. 어떤 기능을 구현하기 위해 한 가지 방법만 보는 것이 아니라, 다른 관점으로 다른 구현 방식을 고민해보고 장/단점을 비교해면서 이야기를 많이 나눴다. 또한 확장성 있는 코드를 짜기 위해 얼마나 멀리 봐야하는지 고민이 되기도 했다. 

실제로 현업에서 업무를 진행하게 되면 지금처럼 정해진 Step처럼 요구사항이 준비되어있지 않을 것이다. 지금은 얼추 "아 이런 기능도 생길 수 있을 것 같으니까, 대비해서 코드를 작성해두자" 정도로만 고민을 해보는 것 같은데, 실제 현업에서 확장성있는 코드를 작성하기 위해 어떻게 하는지 궁금해졌다. 근데 아마 생각해보니, 객체 지향적으로 프로그래밍을 하다보면 각 객체들이 역할과 책임을 갖고 기능을 수행하고 협력한다는 것을 생각해보면, 우선 객체 지향적으로 코드를 구성하는 것이 우선이라고 생각된다!




